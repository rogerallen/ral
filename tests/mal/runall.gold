============================================================
step2_eval
============================================================
Started with:
ral v.0.1 Debug

Testing evaluation of arithmetic operations
TEST: '(+ 1 2)' -> ['',3] -> SUCCESS
TEST: '(+ 5 (* 2 3))' -> ['',11] -> SUCCESS
TEST: '(- (+ 5 (* 2 3)) 3)' -> ['',8] -> SUCCESS
TEST: '(/ (- (+ 5 (* 2 3)) 3) 4)' -> ['',2] -> SUCCESS
TEST: '(/ (- (+ 515 (* 87 311)) 302) 27)' -> ['',1010] -> SUCCESS
TEST: '(* -3 6)' -> ['',-18] -> SUCCESS
TEST: '(/ (- (+ 515 (* -87 311)) 296) 27)' -> ['',-994] -> SUCCESS
TEST: '(abc 1 2 3)' -> ['.+',] -> SUCCESS
Testing empty list
TEST: '()' -> ['',()] -> SUCCESS

-------- Deferrable Functionality --------
Testing evaluation within collection literals
TEST: '[1 2 (+ 1 2)]' -> ['',[1 2 3]] -> SUCCESS
TEST: '{"a" (+ 7 8)}' -> ['',{"a" 15}] -> SUCCESS
TEST: '{:a (+ 7 8)}' -> ['',{:a 15}] -> SUCCESS
Check that evaluation hasn't broken empty collections
TEST: '[]' -> ['',[]] -> SUCCESS
TEST: '{}' -> ['',{}] -> SUCCESS

TEST RESULTS (for ./step2_eval.mal):
    0: soft failing tests
    0: failing tests
   14: passing tests
   14: total tests

============================================================
step3_env
============================================================
Started with:
ral v.0.1 Debug

Testing REPL_ENV
TEST: '(+ 1 2)' -> ['',3] -> SUCCESS
TEST: '(/ (- (+ 5 (* 2 3)) 3) 4)' -> ['',2] -> SUCCESS
Testing def!
TEST: '(def! x 3)' -> ['',3] -> SUCCESS
TEST: 'x' -> ['',3] -> SUCCESS
TEST: '(def! x 4)' -> ['',4] -> SUCCESS
TEST: 'x' -> ['',4] -> SUCCESS
TEST: '(def! y (+ 1 7))' -> ['',8] -> SUCCESS
TEST: 'y' -> ['',8] -> SUCCESS
Verifying symbols are case-sensitive
TEST: '(def! mynum 111)' -> ['',111] -> SUCCESS
TEST: '(def! MYNUM 222)' -> ['',222] -> SUCCESS
TEST: 'mynum' -> ['',111] -> SUCCESS
TEST: 'MYNUM' -> ['',222] -> SUCCESS
Check env lookup non-fatal error
TEST: '(abc 1 2 3)' -> [".*\\'?abc\\'? not found.*",] -> SUCCESS
Check that error aborts def!
TEST: '(def! w 123)' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! w (abc))' -> ['',] -> SUCCESS (result ignored)
TEST: 'w' -> ['',123] -> SUCCESS
Testing let*
TEST: '(let* (z 9) z)' -> ['',9] -> SUCCESS
TEST: '(let* (x 9) x)' -> ['',9] -> SUCCESS
TEST: 'x' -> ['',4] -> SUCCESS
TEST: '(let* (z (+ 2 3)) (+ 1 z))' -> ['',6] -> SUCCESS
TEST: '(let* (p (+ 2 3) q (+ 2 p)) (+ p q))' -> ['',12] -> SUCCESS
TEST: '(def! y (let* (z 7) z))' -> ['',] -> SUCCESS (result ignored)
TEST: 'y' -> ['',7] -> SUCCESS
Testing outer environment
TEST: '(def! a 4)' -> ['',4] -> SUCCESS
TEST: '(let* (q 9) q)' -> ['',9] -> SUCCESS
TEST: '(let* (q 9) a)' -> ['',4] -> SUCCESS
TEST: '(let* (z 2) (let* (q 9) a))' -> ['',4] -> SUCCESS

-------- Deferrable Functionality --------
Testing let* with vector bindings
TEST: '(let* [z 9] z)' -> ['',9] -> SUCCESS
TEST: '(let* [p (+ 2 3) q (+ 2 p)] (+ p q))' -> ['',12] -> SUCCESS
Testing vector evaluation
TEST: '(let* (a 5 b 6) [3 4 a [b 7] 8])' -> ['',[3 4 5 [6 7] 8]] -> SUCCESS

TEST RESULTS (for ./step3_env.mal):
    0: soft failing tests
    0: failing tests
   30: passing tests
   30: total tests

============================================================
step4_if_fn_do
============================================================
Started with:
ral v.0.1 Debug

-----------------------------------------------------
Testing list functions
TEST: '(list)' -> ['',()] -> SUCCESS
TEST: '(list? (list))' -> ['',true] -> SUCCESS
TEST: '(empty? (list))' -> ['',true] -> SUCCESS
TEST: '(empty? (list 1))' -> ['',false] -> SUCCESS
TEST: '(list 1 2 3)' -> ['',(1 2 3)] -> SUCCESS
TEST: '(count (list 1 2 3))' -> ['',3] -> SUCCESS
TEST: '(count (list))' -> ['',0] -> SUCCESS
TEST: '(count nil)' -> ['',0] -> SUCCESS
TEST: '(if (> (count (list 1 2 3)) 3) 89 78)' -> ['',78] -> SUCCESS
TEST: '(if (>= (count (list 1 2 3)) 3) 89 78)' -> ['',89] -> SUCCESS
Testing if form
TEST: '(if true 7 8)' -> ['',7] -> SUCCESS
TEST: '(if false 7 8)' -> ['',8] -> SUCCESS
TEST: '(if false 7 false)' -> ['',false] -> SUCCESS
TEST: '(if true (+ 1 7) (+ 1 8))' -> ['',8] -> SUCCESS
TEST: '(if false (+ 1 7) (+ 1 8))' -> ['',9] -> SUCCESS
TEST: '(if nil 7 8)' -> ['',8] -> SUCCESS
TEST: '(if 0 7 8)' -> ['',7] -> SUCCESS
TEST: '(if (list) 7 8)' -> ['',7] -> SUCCESS
TEST: '(if (list 1 2 3) 7 8)' -> ['',7] -> SUCCESS
TEST: '(= (list) nil)' -> ['',false] -> SUCCESS
Testing 1-way if form
TEST: '(if false (+ 1 7))' -> ['',nil] -> SUCCESS
TEST: '(if nil 8)' -> ['',nil] -> SUCCESS
TEST: '(if nil 8 7)' -> ['',7] -> SUCCESS
TEST: '(if true (+ 1 7))' -> ['',8] -> SUCCESS
Testing basic conditionals
TEST: '(= 2 1)' -> ['',false] -> SUCCESS
TEST: '(= 1 1)' -> ['',true] -> SUCCESS
TEST: '(= 1 2)' -> ['',false] -> SUCCESS
TEST: '(= 1 (+ 1 1))' -> ['',false] -> SUCCESS
TEST: '(= 2 (+ 1 1))' -> ['',true] -> SUCCESS
TEST: '(= nil 1)' -> ['',false] -> SUCCESS
TEST: '(= nil nil)' -> ['',true] -> SUCCESS
TEST: '(> 2 1)' -> ['',true] -> SUCCESS
TEST: '(> 1 1)' -> ['',false] -> SUCCESS
TEST: '(> 1 2)' -> ['',false] -> SUCCESS
TEST: '(>= 2 1)' -> ['',true] -> SUCCESS
TEST: '(>= 1 1)' -> ['',true] -> SUCCESS
TEST: '(>= 1 2)' -> ['',false] -> SUCCESS
TEST: '(< 2 1)' -> ['',false] -> SUCCESS
TEST: '(< 1 1)' -> ['',false] -> SUCCESS
TEST: '(< 1 2)' -> ['',true] -> SUCCESS
TEST: '(<= 2 1)' -> ['',false] -> SUCCESS
TEST: '(<= 1 1)' -> ['',true] -> SUCCESS
TEST: '(<= 1 2)' -> ['',true] -> SUCCESS
Testing equality
TEST: '(= 1 1)' -> ['',true] -> SUCCESS
TEST: '(= 0 0)' -> ['',true] -> SUCCESS
TEST: '(= 1 0)' -> ['',false] -> SUCCESS
TEST: '(= true true)' -> ['',true] -> SUCCESS
TEST: '(= false false)' -> ['',true] -> SUCCESS
TEST: '(= nil nil)' -> ['',true] -> SUCCESS
TEST: '(= (list) (list))' -> ['',true] -> SUCCESS
TEST: '(= (list 1 2) (list 1 2))' -> ['',true] -> SUCCESS
TEST: '(= (list 1) (list))' -> ['',false] -> SUCCESS
TEST: '(= (list) (list 1))' -> ['',false] -> SUCCESS
TEST: '(= 0 (list))' -> ['',false] -> SUCCESS
TEST: '(= (list) 0)' -> ['',false] -> SUCCESS
TEST: '(= (list nil) (list))' -> ['',false] -> SUCCESS
Testing builtin and user defined functions
TEST: '(+ 1 2)' -> ['',3] -> SUCCESS
TEST: '( (fn* (a b) (+ b a)) 3 4)' -> ['',7] -> SUCCESS
TEST: '( (fn* () 4) )' -> ['',4] -> SUCCESS
TEST: '( (fn* (f x) (f x)) (fn* (a) (+ 1 a)) 7)' -> ['',8] -> SUCCESS
Testing closures
TEST: '( ( (fn* (a) (fn* (b) (+ a b))) 5) 7)' -> ['',12] -> SUCCESS
TEST: '(def! gen-plus5 (fn* () (fn* (b) (+ 5 b))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! plus5 (gen-plus5))' -> ['',] -> SUCCESS (result ignored)
TEST: '(plus5 7)' -> ['',12] -> SUCCESS
TEST: '(def! gen-plusX (fn* (x) (fn* (b) (+ x b))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! plus7 (gen-plusX 7))' -> ['',] -> SUCCESS (result ignored)
TEST: '(plus7 8)' -> ['',15] -> SUCCESS
Testing do form
TEST: '(do (prn 101))' -> ['101\n',nil] -> SUCCESS
TEST: '(do (prn 102) 7)' -> ['102\n',7] -> SUCCESS
TEST: '(do (prn 101) (prn 102) (+ 1 2))' -> ['101\n102\n',3] -> SUCCESS
TEST: '(do (def! a 6) 7 (+ a 8))' -> ['',14] -> SUCCESS
TEST: 'a' -> ['',6] -> SUCCESS
Testing special form case-sensitivity
TEST: '(def! DO (fn* (a) 7))' -> ['',] -> SUCCESS (result ignored)
TEST: '(DO 3)' -> ['',7] -> SUCCESS
Testing recursive sumdown function
TEST: '(def! sumdown (fn* (N) (if (> N 0) (+ N (sumdown  (- N 1))) 0)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(sumdown 1)' -> ['',1] -> SUCCESS
TEST: '(sumdown 2)' -> ['',3] -> SUCCESS
TEST: '(sumdown 6)' -> ['',21] -> SUCCESS
Testing recursive fibonacci function
TEST: '(def! fib (fn* (N) (if (= N 0) 1 (if (= N 1) 1 (+ (fib (- N 1)) (fib (- N 2)))))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(fib 1)' -> ['',1] -> SUCCESS
TEST: '(fib 2)' -> ['',2] -> SUCCESS
TEST: '(fib 4)' -> ['',5] -> SUCCESS
Testing recursive function in environment.
TEST: '(let* (cst (fn* (n) (if (= n 0) nil (cst (- n 1))))) (cst 1))' -> ['',nil] -> SUCCESS
TEST: '(let* (f (fn* (n) (if (= n 0) 0 (g (- n 1)))) g (fn* (n) (f n))) (f 2))' -> ['',0] -> SUCCESS

-------- Deferrable Functionality --------
Testing if on strings
TEST: '(if "" 7 8)' -> ['',7] -> SUCCESS
Testing string equality
TEST: '(= "" "")' -> ['',true] -> SUCCESS
TEST: '(= "abc" "abc")' -> ['',true] -> SUCCESS
TEST: '(= "abc" "")' -> ['',false] -> SUCCESS
TEST: '(= "" "abc")' -> ['',false] -> SUCCESS
TEST: '(= "abc" "def")' -> ['',false] -> SUCCESS
TEST: '(= "abc" "ABC")' -> ['',false] -> SUCCESS
TEST: '(= (list) "")' -> ['',false] -> SUCCESS
TEST: '(= "" (list))' -> ['',false] -> SUCCESS
Testing variable length arguments
TEST: '( (fn* (& more) (count more)) 1 2 3)' -> ['',3] -> SUCCESS
TEST: '( (fn* (& more) (list? more)) 1 2 3)' -> ['',true] -> SUCCESS
TEST: '( (fn* (& more) (count more)) 1)' -> ['',1] -> SUCCESS
TEST: '( (fn* (& more) (count more)) )' -> ['',0] -> SUCCESS
TEST: '( (fn* (& more) (list? more)) )' -> ['',true] -> SUCCESS
TEST: '( (fn* (a & more) (count more)) 1 2 3)' -> ['',2] -> SUCCESS
TEST: '( (fn* (a & more) (count more)) 1)' -> ['',0] -> SUCCESS
TEST: '( (fn* (a & more) (list? more)) 1)' -> ['',true] -> SUCCESS
Testing language defined not function
TEST: '(not false)' -> ['',true] -> SUCCESS
TEST: '(not nil)' -> ['',true] -> SUCCESS
TEST: '(not true)' -> ['',false] -> SUCCESS
TEST: '(not "a")' -> ['',false] -> SUCCESS
TEST: '(not 0)' -> ['',false] -> SUCCESS
-----------------------------------------------------
Testing string quoting
TEST: '""' -> ['',""] -> SUCCESS
TEST: '"abc"' -> ['',"abc"] -> SUCCESS
TEST: '"abc  def"' -> ['',"abc  def"] -> SUCCESS
TEST: '"\\""' -> ['',"\""] -> SUCCESS
TEST: '"abc\\ndef\\nghi"' -> ['',"abc\ndef\nghi"] -> SUCCESS
TEST: '"abc\\\\def\\\\ghi"' -> ['',"abc\\def\\ghi"] -> SUCCESS
TEST: '"\\\\n"' -> ['',"\\n"] -> SUCCESS
Testing pr-str
TEST: '(pr-str)' -> ['',""] -> SUCCESS
TEST: '(pr-str "")' -> ['',"\"\""] -> SUCCESS
TEST: '(pr-str "abc")' -> ['',"\"abc\""] -> SUCCESS
TEST: '(pr-str "abc  def" "ghi jkl")' -> ['',"\"abc  def\" \"ghi jkl\""] -> SUCCESS
TEST: '(pr-str "\\"")' -> ['',"\"\\\"\""] -> SUCCESS
TEST: '(pr-str (list 1 2 "abc" "\\"") "def")' -> ['',"(1 2 \"abc\" \"\\\"\") \"def\""] -> SUCCESS
TEST: '(pr-str "abc\\ndef\\nghi")' -> ['',"\"abc\\ndef\\nghi\""] -> SUCCESS
TEST: '(pr-str "abc\\\\def\\\\ghi")' -> ['',"\"abc\\\\def\\\\ghi\""] -> SUCCESS
TEST: '(pr-str (list))' -> ['',"()"] -> SUCCESS
Testing str
TEST: '(str)' -> ['',""] -> SUCCESS
TEST: '(str "")' -> ['',""] -> SUCCESS
TEST: '(str "abc")' -> ['',"abc"] -> SUCCESS
TEST: '(str "\\"")' -> ['',"\""] -> SUCCESS
TEST: '(str 1 "abc" 3)' -> ['',"1abc3"] -> SUCCESS
TEST: '(str "abc  def" "ghi jkl")' -> ['',"abc  defghi jkl"] -> SUCCESS
TEST: '(str "abc\\ndef\\nghi")' -> ['',"abc\ndef\nghi"] -> SUCCESS
TEST: '(str "abc\\\\def\\\\ghi")' -> ['',"abc\\def\\ghi"] -> SUCCESS
TEST: '(str (list 1 2 "abc" "\\"") "def")' -> ['',"(1 2 abc \")def"] -> SUCCESS
TEST: '(str (list))' -> ['',"()"] -> SUCCESS
Testing prn
TEST: '(prn)' -> ['\n',nil] -> SUCCESS
TEST: '(prn "")' -> ['""\n',nil] -> SUCCESS
TEST: '(prn "abc")' -> ['"abc"\n',nil] -> SUCCESS
TEST: '(prn "abc  def" "ghi jkl")' -> ['"abc  def" "ghi jkl"',] -> SUCCESS
TEST: '(prn "\\"")' -> ['"\\\\""\n',nil] -> SUCCESS
TEST: '(prn "abc\\ndef\\nghi")' -> ['"abc\\\\ndef\\\\nghi"\n',nil] -> SUCCESS
TEST: '(prn "abc\\\\def\\\\ghi")' -> ['"abc\\\\\\\\def\\\\\\\\ghi"',] -> SUCCESS
TEST: 'nil' -> ['',] -> SUCCESS (result ignored)
TEST: '(prn (list 1 2 "abc" "\\"") "def")' -> ['\\(1 2 "abc" "\\\\""\\) "def"\n',nil] -> SUCCESS
Testing println
TEST: '(println)' -> ['\n',nil] -> SUCCESS
TEST: '(println "")' -> ['\n',nil] -> SUCCESS
TEST: '(println "abc")' -> ['abc\n',nil] -> SUCCESS
TEST: '(println "abc  def" "ghi jkl")' -> ['abc  def ghi jkl',] -> SUCCESS
TEST: '(println "\\"")' -> ['"\n',nil] -> SUCCESS
TEST: '(println "abc\\ndef\\nghi")' -> ['abc\ndef\nghi\n',nil] -> SUCCESS
TEST: '(println "abc\\\\def\\\\ghi")' -> ['abc\\\\def\\\\ghi\n',nil] -> SUCCESS
TEST: '(println (list 1 2 "abc" "\\"") "def")' -> ['\\(1 2 abc "\\) def\n',nil] -> SUCCESS
Testing keywords
TEST: '(= :abc :abc)' -> ['',true] -> SUCCESS
TEST: '(= :abc :def)' -> ['',false] -> SUCCESS
TEST: '(= :abc ":abc")' -> ['',false] -> SUCCESS
TEST: '(= (list :abc) (list :abc))' -> ['',true] -> SUCCESS
Testing vector truthiness
TEST: '(if [] 7 8)' -> ['',7] -> SUCCESS
Testing vector printing
TEST: '(pr-str [1 2 "abc" "\\""] "def")' -> ['',"[1 2 \"abc\" \"\\\"\"] \"def\""] -> SUCCESS
TEST: '(pr-str [])' -> ['',"[]"] -> SUCCESS
TEST: '(str [1 2 "abc" "\\""] "def")' -> ['',"[1 2 abc \"]def"] -> SUCCESS
TEST: '(str [])' -> ['',"[]"] -> SUCCESS
Testing vector functions
TEST: '(count [1 2 3])' -> ['',3] -> SUCCESS
TEST: '(empty? [1 2 3])' -> ['',false] -> SUCCESS
TEST: '(empty? [])' -> ['',true] -> SUCCESS
TEST: '(list? [4 5 6])' -> ['',false] -> SUCCESS
Testing vector equality
TEST: '(= [] (list))' -> ['',true] -> SUCCESS
TEST: '(= [7 8] [7 8])' -> ['',true] -> SUCCESS
TEST: '(= [:abc] [:abc])' -> ['',true] -> SUCCESS
TEST: '(= (list 1 2) [1 2])' -> ['',true] -> SUCCESS
TEST: '(= (list 1) [])' -> ['',false] -> SUCCESS
TEST: '(= [] [1])' -> ['',false] -> SUCCESS
TEST: '(= 0 [])' -> ['',false] -> SUCCESS
TEST: '(= [] 0)' -> ['',false] -> SUCCESS
TEST: '(= [] "")' -> ['',false] -> SUCCESS
TEST: '(= "" [])' -> ['',false] -> SUCCESS
Testing vector parameter lists
TEST: '( (fn* [] 4) )' -> ['',4] -> SUCCESS
TEST: '( (fn* [f x] (f x)) (fn* [a] (+ 1 a)) 7)' -> ['',8] -> SUCCESS
Nested vector/list equality
TEST: '(= [(list)] (list []))' -> ['',true] -> SUCCESS
TEST: '(= [1 2 (list 3 4 [5 6])] (list 1 2 [3 4 (list 5 6)]))' -> ['',true] -> SUCCESS

TEST RESULTS (for ./step4_if_fn_do.mal):
    0: soft failing tests
    0: failing tests
  176: passing tests
  176: total tests

============================================================
step5_tco
============================================================
Started with:
ral v.0.1 Debug

Testing recursive tail-call function
TEST: '(def! sum2 (fn* (n acc) (if (= n 0) acc (sum2 (- n 1) (+ n acc)))))' -> ['',] -> SUCCESS (result ignored)
TODO: test let*, and do for TCO
TEST: '(sum2 10 0)' -> ['',55] -> SUCCESS
TEST: '(def! res2 nil)' -> ['',nil] -> SUCCESS
TEST: '(def! res2 (sum2 10000 0))' -> ['',] -> SUCCESS (result ignored)
TEST: 'res2' -> ['',50005000] -> SUCCESS
Test mutually recursive tail-call functions
TEST: '(def! foo (fn* (n) (if (= n 0) 0 (bar (- n 1)))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! bar (fn* (n) (if (= n 0) 0 (foo (- n 1)))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(foo 10000)' -> ['',0] -> SUCCESS

TEST RESULTS (for ./step5_tco.mal):
    0: soft failing tests
    0: failing tests
    8: passing tests
    8: total tests

============================================================
step6_file
============================================================
Started with:
ral v.0.1 Debug


Testing that (do (do)) not broken by TCO
TEST: '(do (do 1 2))' -> ['',2] -> SUCCESS

Testing read-string, eval and slurp
TEST: '(read-string "(1 2 (3 4) nil)")' -> ['',(1 2 (3 4) nil)] -> SUCCESS
TEST: '(= nil (read-string "nil"))' -> ['',true] -> SUCCESS
TEST: '(read-string "(+ 2 3)")' -> ['',(+ 2 3)] -> SUCCESS
TEST: '(read-string "\\"\\n\\"")' -> ['',"\n"] -> SUCCESS
TEST: '(read-string "7 ;; comment")' -> ['',7] -> SUCCESS
TEST: '(read-string ";; comment")' -> ['',] -> SUCCESS (result ignored)
TEST: '(eval (read-string "(+ 2 3)"))' -> ['',5] -> SUCCESS
TEST: '(slurp "./test.txt")' -> ['',"A line of text\n"] -> SUCCESS
TEST: '(slurp "./test.txt")' -> ['',"A line of text\n"] -> SUCCESS
Testing load-file
TEST: '(load-file "./inc.mal")' -> ['',nil] -> SUCCESS
TEST: '(inc1 7)' -> ['',8] -> SUCCESS
TEST: '(inc2 7)' -> ['',9] -> SUCCESS
TEST: '(inc3 9)' -> ['',12] -> SUCCESS

Testing atoms
TEST: '(def! inc3 (fn* (a) (+ 3 a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! a (atom 2))' -> ['',(atom 2)] -> SUCCESS
TEST: '(atom? a)' -> ['',true] -> SUCCESS
TEST: '(atom? 1)' -> ['',false] -> SUCCESS
TEST: '(deref a)' -> ['',2] -> SUCCESS
TEST: '(reset! a 3)' -> ['',3] -> SUCCESS
TEST: '(deref a)' -> ['',3] -> SUCCESS
TEST: '(swap! a inc3)' -> ['',6] -> SUCCESS
TEST: '(deref a)' -> ['',6] -> SUCCESS
TEST: '(swap! a (fn* (a) a))' -> ['',6] -> SUCCESS
TEST: '(swap! a (fn* (a) (* 2 a)))' -> ['',12] -> SUCCESS
TEST: '(swap! a (fn* (a b) (* a b)) 10)' -> ['',120] -> SUCCESS
TEST: '(swap! a + 3)' -> ['',123] -> SUCCESS
Testing swap!/closure interaction
TEST: '(def! inc-it (fn* (a) (+ 1 a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! atm (atom 7))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! f (fn* () (swap! atm inc-it)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(f)' -> ['',8] -> SUCCESS
TEST: '(f)' -> ['',9] -> SUCCESS
Testing whether closures can retain atoms
TEST: '(def! g (let* (atm (atom 0)) (fn* () (deref atm))))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! atm (atom 1))' -> ['',] -> SUCCESS (result ignored)
TEST: '(g)' -> ['',0] -> SUCCESS

-------- Deferrable Functionality --------
Testing reading of large files
TEST: '(load-file "./computations.mal")' -> ['',nil] -> SUCCESS
TEST: '(sumdown 2)' -> ['',3] -> SUCCESS
TEST: '(fib 2)' -> ['',1] -> SUCCESS
Testing `@` reader macro (short for `deref`)
TEST: '(def! atm (atom 9))' -> ['',] -> SUCCESS (result ignored)
TEST: '@atm' -> ['',9] -> SUCCESS
Testing that vector params not broken by TCO
TEST: '(def! g (fn* [] 78))' -> ['',] -> SUCCESS (result ignored)
TEST: '(g)' -> ['',78] -> SUCCESS
TEST: '(def! g (fn* [a] (+ a 78)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(g 3)' -> ['',81] -> SUCCESS

Testing that *ARGV* exists and is an empty list
TEST: '(list? *ARGV*)' -> ['',true] -> SUCCESS
TEST: '*ARGV*' -> ['',()] -> SUCCESS

Testing that eval sets aa in root scope, and that it is found in nested scope
TEST: '(let* (b 12) (do (eval (read-string "(def! aa 7)")) aa ))' -> ['',7] -> SUCCESS

-------- Optional Functionality --------
Testing comments in a file
TEST: '(load-file "./incB.mal")' -> ['',nil] -> SUCCESS
TEST: '(inc4 7)' -> ['',11] -> SUCCESS
TEST: '(inc5 7)' -> ['',12] -> SUCCESS
Testing map literal across multiple lines in a file
TEST: '(load-file "./incC.mal")' -> ['',nil] -> SUCCESS
TEST: 'mymap' -> ['',{"a" 1}] -> SUCCESS
Checking that eval does not use local environments.
TEST: '(def! a 1)' -> ['',1] -> SUCCESS
TEST: '(let* (a 2) (eval (read-string "a")))' -> ['',1] -> SUCCESS
Non alphanumeric characters in comments in read-string
TEST: '(read-string "1;!")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\\"")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;#")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;$")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;%")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\'")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\\\\")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\\\\\\\\")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;\\\\\\\\\\\\")' -> ['',1] -> SUCCESS
TEST: '(read-string "1;`")' -> ['',1] -> SUCCESS
TEST: '(read-string "1; &()*+,-./:;<=>?@[]^_{|}~")' -> ['',1] -> SUCCESS

TEST RESULTS (for ./step6_file.mal):
    0: soft failing tests
    0: failing tests
   65: passing tests
   65: total tests

============================================================
step7_quote
============================================================
Started with:
ral v.0.1 Debug

Testing cons function
TEST: '(cons 1 (list))' -> ['',(1)] -> SUCCESS
TEST: '(cons 1 (list 2))' -> ['',(1 2)] -> SUCCESS
TEST: '(cons 1 (list 2 3))' -> ['',(1 2 3)] -> SUCCESS
TEST: '(cons (list 1) (list 2 3))' -> ['',((1) 2 3)] -> SUCCESS
TEST: '(def! a (list 2 3))' -> ['',] -> SUCCESS (result ignored)
TEST: '(cons 1 a)' -> ['',(1 2 3)] -> SUCCESS
TEST: 'a' -> ['',(2 3)] -> SUCCESS
Testing concat function
TEST: '(concat)' -> ['',()] -> SUCCESS
TEST: '(concat (list 1 2))' -> ['',(1 2)] -> SUCCESS
TEST: '(concat (list 1 2) (list 3 4))' -> ['',(1 2 3 4)] -> SUCCESS
TEST: '(concat (list 1 2) (list 3 4) (list 5 6))' -> ['',(1 2 3 4 5 6)] -> SUCCESS
TEST: '(concat (concat))' -> ['',()] -> SUCCESS
TEST: '(concat (list) (list))' -> ['',()] -> SUCCESS
TEST: '(def! a (list 1 2))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! b (list 3 4))' -> ['',] -> SUCCESS (result ignored)
TEST: '(concat a b (list 5 6))' -> ['',(1 2 3 4 5 6)] -> SUCCESS
TEST: 'a' -> ['',(1 2)] -> SUCCESS
TEST: 'b' -> ['',(3 4)] -> SUCCESS
Testing regular quote
TEST: '(quote 7)' -> ['',7] -> SUCCESS
TEST: '(quote (1 2 3))' -> ['',(1 2 3)] -> SUCCESS
TEST: '(quote (1 2 (3 4)))' -> ['',(1 2 (3 4))] -> SUCCESS
Testing simple quasiquote
TEST: '(quasiquote 7)' -> ['',7] -> SUCCESS
TEST: '(quasiquote (1 2 3))' -> ['',(1 2 3)] -> SUCCESS
TEST: '(quasiquote (1 2 (3 4)))' -> ['',(1 2 (3 4))] -> SUCCESS
TEST: '(quasiquote (nil))' -> ['',(nil)] -> SUCCESS
Testing unquote
TEST: '(quasiquote (unquote 7))' -> ['',7] -> SUCCESS
TEST: '(def! a 8)' -> ['',8] -> SUCCESS
TEST: '(quasiquote a)' -> ['',a] -> SUCCESS
TEST: '(quasiquote (unquote a))' -> ['',8] -> SUCCESS
TEST: '(quasiquote (1 a 3))' -> ['',(1 a 3)] -> SUCCESS
TEST: '(quasiquote (1 (unquote a) 3))' -> ['',(1 8 3)] -> SUCCESS
TEST: '(def! b (quote (1 "b" "d")))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '(quasiquote (1 b 3))' -> ['',(1 b 3)] -> SUCCESS
TEST: '(quasiquote (1 (unquote b) 3))' -> ['',(1 (1 "b" "d") 3)] -> SUCCESS
TEST: '(quasiquote ((unquote 1) (unquote 2)))' -> ['',(1 2)] -> SUCCESS
Testing splice-unquote
TEST: '(def! c (quote (1 "b" "d")))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '(quasiquote (1 c 3))' -> ['',(1 c 3)] -> SUCCESS
TEST: '(quasiquote (1 (splice-unquote c) 3))' -> ['',(1 1 "b" "d" 3)] -> SUCCESS
Testing symbol equality
TEST: '(= (quote abc) (quote abc))' -> ['',true] -> SUCCESS
TEST: '(= (quote abc) (quote abcd))' -> ['',false] -> SUCCESS
TEST: '(= (quote abc) "abc")' -> ['',false] -> SUCCESS
TEST: '(= "abc" (quote abc))' -> ['',false] -> SUCCESS
TEST: '(= "abc" (str (quote abc)))' -> ['',true] -> SUCCESS
TEST: '(= (quote abc) nil)' -> ['',false] -> SUCCESS
TEST: '(= nil (quote abc))' -> ['',false] -> SUCCESS

-------- Deferrable Functionality --------
Testing ' (quote) reader macro
TEST: "'7" -> ['',7] -> SUCCESS
TEST: "'(1 2 3)" -> ['',(1 2 3)] -> SUCCESS
TEST: "'(1 2 (3 4))" -> ['',(1 2 (3 4))] -> SUCCESS
Testing cons and concat with vectors
TEST: '(cons [1] [2 3])' -> ['',([1] 2 3)] -> SUCCESS
TEST: '(cons 1 [2 3])' -> ['',(1 2 3)] -> SUCCESS
TEST: '(concat [1 2] (list 3 4) [5 6])' -> ['',(1 2 3 4 5 6)] -> SUCCESS
TEST: '(concat [1 2])' -> ['',(1 2)] -> SUCCESS

-------- Optional Functionality --------
Testing ` (quasiquote) reader macro
TEST: '`7' -> ['',7] -> SUCCESS
TEST: '`(1 2 3)' -> ['',(1 2 3)] -> SUCCESS
TEST: '`(1 2 (3 4))' -> ['',(1 2 (3 4))] -> SUCCESS
TEST: '`(nil)' -> ['',(nil)] -> SUCCESS
Testing ~ (unquote) reader macro
TEST: '`~7' -> ['',7] -> SUCCESS
TEST: '(def! a 8)' -> ['',8] -> SUCCESS
TEST: '`(1 ~a 3)' -> ['',(1 8 3)] -> SUCCESS
TEST: '(def! b \'(1 "b" "d"))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '`(1 b 3)' -> ['',(1 b 3)] -> SUCCESS
TEST: '`(1 ~b 3)' -> ['',(1 (1 "b" "d") 3)] -> SUCCESS
Testing ~@ (splice-unquote) reader macro
TEST: '(def! c \'(1 "b" "d"))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '`(1 c 3)' -> ['',(1 c 3)] -> SUCCESS
TEST: '`(1 ~@c 3)' -> ['',(1 1 "b" "d" 3)] -> SUCCESS
Testing unquote with vectors
TEST: '(def! a 8)' -> ['',8] -> SUCCESS
TEST: '`[1 a 3]' -> ['',(1 a 3)] -> SUCCESS
Testing splice-unquote with vectors
TEST: '(def! c \'(1 "b" "d"))' -> ['',(1 "b" "d")] -> SUCCESS
TEST: '`[1 ~@c 3]' -> ['',(1 1 "b" "d" 3)] -> SUCCESS

TEST RESULTS (for ./step7_quote.mal):
    0: soft failing tests
    0: failing tests
   69: passing tests
   69: total tests

============================================================
step8_macros
============================================================
Started with:
ral v.0.1 Debug

Testing trivial macros
TEST: '(defmacro! one (fn* () 1))' -> ['',] -> SUCCESS (result ignored)
TEST: '(one)' -> ['',1] -> SUCCESS
TEST: '(defmacro! two (fn* () 2))' -> ['',] -> SUCCESS (result ignored)
TEST: '(two)' -> ['',2] -> SUCCESS
Testing unless macros
TEST: '(defmacro! unless (fn* (pred a b) `(if ~pred ~b ~a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(unless false 7 8)' -> ['',7] -> SUCCESS
TEST: '(unless true 7 8)' -> ['',8] -> SUCCESS
TEST: "(defmacro! unless2 (fn* (pred a b) (list 'if (list 'not pred) a b)))" -> ['',] -> SUCCESS (result ignored)
TEST: '(unless2 false 7 8)' -> ['',7] -> SUCCESS
TEST: '(unless2 true 7 8)' -> ['',8] -> SUCCESS
Testing macroexpand
TEST: '(macroexpand (unless2 2 3 4))' -> ['',(if (not 2) 3 4)] -> SUCCESS
Testing evaluation of macro result
TEST: '(defmacro! identity (fn* (x) x))' -> ['',] -> SUCCESS (result ignored)
TEST: '(let* (a 123) (identity a))' -> ['',123] -> SUCCESS
Test that macros do not break empty list
TEST: '()' -> ['',()] -> SUCCESS

-------- Deferrable Functionality --------
Testing non-macro function
TEST: '(not (= 1 1))' -> ['',false] -> SUCCESS
TEST: '(not (= 1 2))' -> ['',true] -> SUCCESS
Testing nth, first and rest functions
TEST: '(nth (list 1) 0)' -> ['',1] -> SUCCESS
TEST: '(nth (list 1 2) 1)' -> ['',2] -> SUCCESS
TEST: '(nth (list 1 2 nil) 2)' -> ['',nil] -> SUCCESS
TEST: '(def! x "x")' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! x (nth (list 1 2) 2))' -> ['',] -> SUCCESS (result ignored)
TEST: 'x' -> ['',"x"] -> SUCCESS
TEST: '(first (list))' -> ['',nil] -> SUCCESS
TEST: '(first (list 6))' -> ['',6] -> SUCCESS
TEST: '(first (list 7 8 9))' -> ['',7] -> SUCCESS
TEST: '(rest (list))' -> ['',()] -> SUCCESS
TEST: '(rest (list 6))' -> ['',()] -> SUCCESS
TEST: '(rest (list 7 8 9))' -> ['',(8 9)] -> SUCCESS
Testing cond macro
TEST: '(cond)' -> ['',nil] -> SUCCESS
TEST: '(cond true 7)' -> ['',7] -> SUCCESS
TEST: '(cond true 7 true 8)' -> ['',7] -> SUCCESS
TEST: '(cond false 7 true 8)' -> ['',8] -> SUCCESS
TEST: '(cond false 7 false 8 "else" 9)' -> ['',9] -> SUCCESS
TEST: '(cond false 7 (= 2 2) 8 "else" 9)' -> ['',8] -> SUCCESS
TEST: '(cond false 7 false 8 false 9)' -> ['',nil] -> SUCCESS
Testing EVAL in let*
TEST: '(let* (x (cond false "no" true "yes")) x)' -> ['',"yes"] -> SUCCESS
Testing nth, first, rest with vectors
TEST: '(nth [1] 0)' -> ['',1] -> SUCCESS
TEST: '(nth [1 2] 1)' -> ['',2] -> SUCCESS
TEST: '(nth [1 2 nil] 2)' -> ['',nil] -> SUCCESS
TEST: '(def! x "x")' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! x (nth [1 2] 2))' -> ['',] -> SUCCESS (result ignored)
TEST: 'x' -> ['',"x"] -> SUCCESS
TEST: '(first [])' -> ['',nil] -> SUCCESS
TEST: '(first nil)' -> ['',nil] -> SUCCESS
TEST: '(first [10])' -> ['',10] -> SUCCESS
TEST: '(first [10 11 12])' -> ['',10] -> SUCCESS
TEST: '(rest [])' -> ['',()] -> SUCCESS
TEST: '(rest nil)' -> ['',()] -> SUCCESS
TEST: '(rest [10])' -> ['',()] -> SUCCESS
TEST: '(rest [10 11 12])' -> ['',(11 12)] -> SUCCESS
TEST: '(rest (cons 10 [11 12]))' -> ['',(11 12)] -> SUCCESS
Testing EVAL in vector let*
TEST: '(let* [x (cond false "no" true "yes")] x)' -> ['',"yes"] -> SUCCESS

------- Optional Functionality --------------
------- (Not needed for self-hosting) -------
Test that macros use closures
TEST: '(def! x 2)' -> ['',] -> SUCCESS (result ignored)
TEST: '(defmacro! a (fn* [] x))' -> ['',] -> SUCCESS (result ignored)
TEST: '(a)' -> ['',2] -> SUCCESS
TEST: '(let* (x 3) (a))' -> ['',2] -> SUCCESS

TEST RESULTS (for ./step8_macros.mal):
    0: soft failing tests
    0: failing tests
   56: passing tests
   56: total tests

============================================================
step9_try
============================================================
Started with:
ral v.0.1 Debug


Testing throw
TEST: '(throw "err1")' -> ['.*([Ee][Rr][Rr][Oo][Rr]|[Ee]xception).*err1.*',] -> SUCCESS

Testing try*/catch*
TEST: '(try* 123 (catch* e 456))' -> ['',123] -> SUCCESS
TEST: '(try* abc (catch* exc (prn "exc is:" exc)))' -> ['"exc is:" "\'abc\' not found"\n',nil] -> SUCCESS
TEST: '(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))' -> ['"exc is:" "\'abc\' not found"\n',nil] -> SUCCESS
Make sure error from core can be caught
TEST: '(try* (nth () 1) (catch* exc (prn "exc is:" exc)))' -> ['"exc is:".*(length|range|[Bb]ounds|beyond).*\n',nil] -> SUCCESS
TEST: '(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))' -> ['"exc:" "my exception"\n',7] -> SUCCESS
Test that exception handlers get restored correctly
TEST: '(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))' -> ['',"c2"] -> SUCCESS
TEST: '(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))' -> ['',"c2"] -> SUCCESS
TEST: '(try* (map throw (list "my err")) (catch* exc exc))' -> ['',"my err"] -> SUCCESS

Testing builtin functions
TEST: "(symbol? 'abc)" -> ['',true] -> SUCCESS
TEST: '(symbol? "abc")' -> ['',false] -> SUCCESS
TEST: '(nil? nil)' -> ['',true] -> SUCCESS
TEST: '(nil? true)' -> ['',false] -> SUCCESS
TEST: '(true? true)' -> ['',true] -> SUCCESS
TEST: '(true? false)' -> ['',false] -> SUCCESS
TEST: '(true? true?)' -> ['',false] -> SUCCESS
TEST: '(false? false)' -> ['',true] -> SUCCESS
TEST: '(false? true)' -> ['',false] -> SUCCESS
Testing apply function with core functions
TEST: '(apply + (list 2 3))' -> ['',5] -> SUCCESS
TEST: '(apply + 4 (list 5))' -> ['',9] -> SUCCESS
TEST: '(apply prn (list 1 2 "3" (list)))' -> ['1 2 "3" \\(\\)\n',nil] -> SUCCESS
TEST: '(apply prn 1 2 (list "3" (list)))' -> ['1 2 "3" \\(\\)\n',nil] -> SUCCESS
TEST: '(apply list (list))' -> ['',()] -> SUCCESS
TEST: '(apply symbol? (list (quote two)))' -> ['',true] -> SUCCESS
Testing apply function with user functions
TEST: '(apply (fn* (a b) (+ a b)) (list 2 3))' -> ['',5] -> SUCCESS
TEST: '(apply (fn* (a b) (+ a b)) 4 (list 5))' -> ['',9] -> SUCCESS
Testing map function
TEST: '(def! nums (list 1 2 3))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! double (fn* (a) (* 2 a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(double 3)' -> ['',6] -> SUCCESS
TEST: '(map double nums) ' -> ['',(2 4 6)] -> SUCCESS
TEST: '(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))' -> ['',(false true false)] -> SUCCESS

------- Deferrable Functionality ----------
------- (Needed for self-hosting) -------
Testing throwing a hash-map
TEST: '(throw {:msg "err2"})' -> ['.*([Ee][Rr][Rr][Oo][Rr]|[Ee]xception).*msg.*err2.*',] -> SUCCESS
Testing symbol and keyword functions
TEST: '(symbol? :abc)' -> ['',false] -> SUCCESS
TEST: "(symbol? 'abc)" -> ['',true] -> SUCCESS
TEST: '(symbol? "abc")' -> ['',false] -> SUCCESS
TEST: '(symbol? (symbol "abc"))' -> ['',true] -> SUCCESS
TEST: '(keyword? :abc)' -> ['',true] -> SUCCESS
TEST: "(keyword? 'abc)" -> ['',false] -> SUCCESS
TEST: '(keyword? "abc")' -> ['',false] -> SUCCESS
TEST: '(keyword? "")' -> ['',false] -> SUCCESS
TEST: '(keyword? (keyword "abc"))' -> ['',true] -> SUCCESS
TEST: '(symbol "abc")' -> ['',abc] -> SUCCESS
TEST: '(keyword "abc")' -> ['',:abc] -> SUCCESS
Testing sequential? function
TEST: '(sequential? (list 1 2 3))' -> ['',true] -> SUCCESS
TEST: '(sequential? [15])' -> ['',true] -> SUCCESS
TEST: '(sequential? sequential?)' -> ['',false] -> SUCCESS
TEST: '(sequential? nil)' -> ['',false] -> SUCCESS
TEST: '(sequential? "abc")' -> ['',false] -> SUCCESS
Testing apply function with core functions and arguments in vector
TEST: '(apply + 4 [5])' -> ['',9] -> SUCCESS
TEST: '(apply prn 1 2 ["3" 4])' -> ['1 2 "3" 4\n',nil] -> SUCCESS
TEST: '(apply list [])' -> ['',()] -> SUCCESS
Testing apply function with user functions and arguments in vector
TEST: '(apply (fn* (a b) (+ a b)) [2 3])' -> ['',5] -> SUCCESS
TEST: '(apply (fn* (a b) (+ a b)) 4 [5])' -> ['',9] -> SUCCESS
Testing map function with vectors
TEST: '(map (fn* (a) (* 2 a)) [1 2 3])' -> ['',(2 4 6)] -> SUCCESS
TEST: '(map (fn* [& args] (list? args)) [1 2])' -> ['',(true true)] -> SUCCESS
Testing vector functions
TEST: '(vector? [10 11])' -> ['',true] -> SUCCESS
TEST: "(vector? '(12 13))" -> ['',false] -> SUCCESS
TEST: '(vector 3 4 5)' -> ['',[3 4 5]] -> SUCCESS
TEST: '(map? {})' -> ['',true] -> SUCCESS
TEST: "(map? '())" -> ['',false] -> SUCCESS
TEST: '(map? [])' -> ['',false] -> SUCCESS
TEST: "(map? 'abc)" -> ['',false] -> SUCCESS
TEST: '(map? :abc)' -> ['',false] -> SUCCESS

Testing hash-maps
TEST: '(hash-map "a" 1)' -> ['',{"a" 1}] -> SUCCESS
TEST: '{"a" 1}' -> ['',{"a" 1}] -> SUCCESS
TEST: '(assoc {} "a" 1)' -> ['',{"a" 1}] -> SUCCESS
TEST: '(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")' -> ['',1] -> SUCCESS
TEST: '(def! hm1 (hash-map))' -> ['',{}] -> SUCCESS
TEST: '(map? hm1)' -> ['',true] -> SUCCESS
TEST: '(map? 1)' -> ['',false] -> SUCCESS
TEST: '(map? "abc")' -> ['',false] -> SUCCESS
TEST: '(get nil "a")' -> ['',nil] -> SUCCESS
TEST: '(get hm1 "a")' -> ['',nil] -> SUCCESS
TEST: '(contains? hm1 "a")' -> ['',false] -> SUCCESS
TEST: '(def! hm2 (assoc hm1 "a" 1))' -> ['',{"a" 1}] -> SUCCESS
TEST: '(get hm1 "a")' -> ['',nil] -> SUCCESS
TEST: '(contains? hm1 "a")' -> ['',false] -> SUCCESS
TEST: '(get hm2 "a")' -> ['',1] -> SUCCESS
TEST: '(contains? hm2 "a")' -> ['',true] -> SUCCESS
TEST: '(keys hm1)' -> ['',()] -> SUCCESS
TEST: '(keys hm2)' -> ['',("a")] -> SUCCESS
TEST: '(keys {"1" 1})' -> ['',("1")] -> SUCCESS
TEST: '(vals hm1)' -> ['',()] -> SUCCESS
TEST: '(vals hm2)' -> ['',(1)] -> SUCCESS
TEST: '(count (keys (assoc hm2 "b" 2 "c" 3)))' -> ['',3] -> SUCCESS
Testing keywords as hash-map keys
TEST: '(get {:abc 123} :abc)' -> ['',123] -> SUCCESS
TEST: '(contains? {:abc 123} :abc)' -> ['',true] -> SUCCESS
TEST: '(contains? {:abcd 123} :abc)' -> ['',false] -> SUCCESS
TEST: '(assoc {} :bcd 234)' -> ['',{:bcd 234}] -> SUCCESS
TEST: '(keyword? (nth (keys {:abc 123 :def 456}) 0))' -> ['',true] -> SUCCESS
TEST: '(keyword? (nth (vals {"a" :abc "b" :def}) 0))' -> ['',true] -> SUCCESS
Testing whether assoc updates properly
TEST: '(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))' -> ['',] -> SUCCESS (result ignored)
TEST: '(get hm4 :a)' -> ['',3] -> SUCCESS
TEST: '(get hm4 :b)' -> ['',2] -> SUCCESS
TEST: '(get hm4 :c)' -> ['',1] -> SUCCESS
Testing nil as hash-map values
TEST: '(contains? {:abc nil} :abc)' -> ['',true] -> SUCCESS
TEST: '(assoc {} :bcd nil)' -> ['',{:bcd nil}] -> SUCCESS

Additional str and pr-str tests
TEST: '(str "A" {:abc "val"} "Z")' -> ['',"A{:abc val}Z"] -> SUCCESS
TEST: '(str true "." false "." nil "." :keyw "." \'symb)' -> ['',"true.false.nil.:keyw.symb"] -> SUCCESS
TEST: '(pr-str "A" {:abc "val"} "Z")' -> ['',"\"A\" {:abc \"val\"} \"Z\""] -> SUCCESS
TEST: '(pr-str true "." false "." nil "." :keyw "." \'symb)' -> ['',"true \".\" false \".\" nil \".\" :keyw \".\" symb"] -> SUCCESS
TEST: '(def! s (str {:abc "val1" :def "val2"}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)' -> ['',true] -> SUCCESS
TEST: '(def! p (pr-str {:abc "val1" :def "val2"}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(cond (= p "{:abc \\"val1\\" :def \\"val2\\"}") true (= p "{:def \\"val2\\" :abc \\"val1\\"}") true)' -> ['',true] -> SUCCESS

Test extra function arguments as Mal List (bypassing TCO with apply)
TEST: '(apply (fn* (& more) (list? more)) [1 2 3])' -> ['',true] -> SUCCESS
TEST: '(apply (fn* (& more) (list? more)) [])' -> ['',true] -> SUCCESS
TEST: '(apply (fn* (a & more) (list? more)) [1])' -> ['',true] -> SUCCESS

------- Optional Functionality --------------
------- (Not needed for self-hosting) -------

Testing try* without catch*
TEST: '(try* xyz)' -> [".*\\'?xyz\\'? not found.*",] -> SUCCESS

Testing throwing non-strings
TEST: '(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))' -> ['"err:" \\(1 2 3\\)\n',7] -> SOFT FAIL (line 339):
    Expected : '.*\n"err:" \\(1 2 3\\)\n7'
    Got      : '(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))\n"err:" "(1 2 3)"\n7'

Testing dissoc
TEST: '(def! hm3 (assoc hm2 "b" 2))' -> ['',] -> SUCCESS (result ignored)
TEST: '(count (keys hm3))' -> ['',2] -> SUCCESS
TEST: '(count (vals hm3))' -> ['',2] -> SUCCESS
TEST: '(dissoc hm3 "a")' -> ['',{"b" 2}] -> SUCCESS
TEST: '(dissoc hm3 "a" "b")' -> ['',{}] -> SUCCESS
TEST: '(dissoc hm3 "a" "b" "c")' -> ['',{}] -> SUCCESS
TEST: '(count (keys hm3))' -> ['',2] -> SUCCESS
TEST: '(dissoc {:cde 345 :fgh 456} :cde)' -> ['',{:fgh 456}] -> SUCCESS
TEST: '(dissoc {:cde nil :fgh 456} :cde)' -> ['',{:fgh 456}] -> SUCCESS

Testing equality of hash-maps
TEST: '(= {} {})' -> ['',true] -> SUCCESS
TEST: '(= {:a 11 :b 22} (hash-map :b 22 :a 11))' -> ['',true] -> SUCCESS
TEST: '(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))' -> ['',true] -> SUCCESS
TEST: '(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))' -> ['',true] -> SUCCESS
TEST: '(= {:a 11 :b 22} (hash-map :b 23 :a 11))' -> ['',false] -> SUCCESS
TEST: '(= {:a 11 :b 22} (hash-map :a 11))' -> ['',false] -> SUCCESS
TEST: '(= {:a [11 22]} {:a (list 11 22)})' -> ['',true] -> SUCCESS
TEST: '(= {:a 11 :b 22} (list :a 11 :b 22))' -> ['',false] -> SUCCESS
TEST: '(= {} [])' -> ['',false] -> SUCCESS
TEST: '(= [] {})' -> ['',false] -> SUCCESS
TEST: '(keyword :abc)' -> ['',:abc] -> SUCCESS
TEST: '(keyword? (first (keys {":abc" 123 ":def" 456})))' -> ['',false] -> SUCCESS

FAILURES:
SOFT FAILED TEST (line 339): (try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7))) -> ['"err:" \\(1 2 3\\)\n',7]:
    Expected : '.*\n"err:" \\(1 2 3\\)\n7'
    Got      : '(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))\n"err:" "(1 2 3)"\n7'

TEST RESULTS (for ./step9_try.mal):
    1: soft failing tests
    0: failing tests
  130: passing tests
  131: total tests

============================================================
stepA_mal
============================================================
Started with:
ral v.0.1 Debug


Testing readline
TEST: '(readline "mal-user> ")' -> ['',] -> SUCCESS (result ignored)
TEST: '"hello"' -> ['',"\"hello\""] -> SUCCESS

Testing *host-language*
TEST: '(= "something bogus" *host-language*)' -> ['',false] -> SUCCESS

------- Deferrable Functionality ----------
------- (Needed for self-hosting) -------


Testing hash-map evaluation and atoms (i.e. an env)
TEST: '(def! e (atom {"+" +}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(swap! e assoc "-" -)' -> ['',] -> SUCCESS (result ignored)
TEST: '( (get @e "+") 7 8)' -> ['',15] -> SUCCESS
TEST: '( (get @e "-") 11 8)' -> ['',3] -> SUCCESS
TEST: '(swap! e assoc "foo" (list))' -> ['',] -> SUCCESS (result ignored)
TEST: '(get @e "foo")' -> ['',()] -> SUCCESS
TEST: '(swap! e assoc "bar" \'(1 2 3))' -> ['',] -> SUCCESS (result ignored)
TEST: '(get @e "bar")' -> ['',(1 2 3)] -> SUCCESS
Testing for presence of optional functions
TEST: '(do (list time-ms string? number? seq conj meta with-meta fn?) nil)' -> ['',nil] -> SUCCESS
------------------------------------------------------------------

------- Optional Functionality --------------
------- (Not needed for self-hosting) -------
Testing metadata on functions

Testing metadata on mal functions
TEST: '(meta (fn* (a) a))' -> ['',nil] -> SUCCESS
TEST: '(meta (with-meta (fn* (a) a) {"b" 1}))' -> ['',{"b" 1}] -> SUCCESS
TEST: '(meta (with-meta (fn* (a) a) "abc"))' -> ['',"abc"] -> SUCCESS
TEST: '(def! l-wm (with-meta (fn* (a) a) {"b" 2}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(meta l-wm)' -> ['',{"b" 2}] -> SUCCESS
TEST: '(meta (with-meta l-wm {"new_meta" 123}))' -> ['',{"new_meta" 123}] -> SUCCESS
TEST: '(meta l-wm)' -> ['',{"b" 2}] -> SUCCESS
TEST: '(def! f-wm (with-meta (fn* [a] (+ 1 a)) {"abc" 1}))' -> ['',] -> SUCCESS (result ignored)
TEST: '(meta f-wm)' -> ['',{"abc" 1}] -> SUCCESS
TEST: '(meta (with-meta f-wm {"new_meta" 123}))' -> ['',{"new_meta" 123}] -> SUCCESS
TEST: '(meta f-wm)' -> ['',{"abc" 1}] -> SUCCESS
TEST: '(def! f-wm2 ^{"abc" 1} (fn* [a] (+ 1 a)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(meta f-wm2)' -> ['',{"abc" 1}] -> SUCCESS
Meta of native functions should return nil (not fail)
TEST: '(meta +)' -> ['',nil] -> SUCCESS

Make sure closures and metadata co-exist
TEST: '(def! gen-plusX (fn* (x) (with-meta (fn* (b) (+ x b)) {"meta" 1})))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! plus7 (gen-plusX 7))' -> ['',] -> SUCCESS (result ignored)
TEST: '(def! plus8 (gen-plusX 8))' -> ['',] -> SUCCESS (result ignored)
TEST: '(plus7 8)' -> ['',15] -> SUCCESS
TEST: '(meta plus7)' -> ['',{"meta" 1}] -> SUCCESS
TEST: '(meta plus8)' -> ['',{"meta" 1}] -> SUCCESS
TEST: '(meta (with-meta plus7 {"meta" 2}))' -> ['',{"meta" 2}] -> SUCCESS
TEST: '(meta plus8)' -> ['',{"meta" 1}] -> SUCCESS

Testing string? function
TEST: '(string? "")' -> ['',true] -> SUCCESS
TEST: "(string? 'abc)" -> ['',false] -> SUCCESS
TEST: '(string? "abc")' -> ['',true] -> SUCCESS
TEST: '(string? :abc)' -> ['',false] -> SUCCESS
TEST: '(string? (keyword "abc"))' -> ['',false] -> SUCCESS
TEST: '(string? 234)' -> ['',false] -> SUCCESS
TEST: '(string? nil)' -> ['',false] -> SUCCESS
Testing number? function
TEST: '(number? 123)' -> ['',true] -> SUCCESS
TEST: '(number? -1)' -> ['',true] -> SUCCESS
TEST: '(number? nil)' -> ['',false] -> SUCCESS
TEST: '(number? false)' -> ['',false] -> SUCCESS
TEST: '(number? "123")' -> ['',false] -> SUCCESS
TEST: '(def! add1 (fn* (x) (+ x 1)))' -> ['',] -> SUCCESS (result ignored)
Testing fn? function
TEST: '(fn? +)' -> ['',true] -> SUCCESS
TEST: '(fn? add1)' -> ['',true] -> SUCCESS
TEST: '(fn? cond)' -> ['',false] -> SUCCESS
TEST: '(fn? "+")' -> ['',false] -> SUCCESS
TEST: '(fn? :+)' -> ['',false] -> SUCCESS
TEST: '(fn? ^{"ismacro" true} (fn* () 0))' -> ['',true] -> SUCCESS
Testing macro? function
TEST: '(macro? cond)' -> ['',true] -> SUCCESS
TEST: '(macro? +)' -> ['',false] -> SUCCESS
TEST: '(macro? add1)' -> ['',false] -> SUCCESS
TEST: '(macro? "+")' -> ['',false] -> SUCCESS
TEST: '(macro? :+)' -> ['',false] -> SUCCESS
TEST: '(macro? {})' -> ['',false] -> SUCCESS

Testing conj function
TEST: '(conj (list) 1)' -> ['',(1)] -> SUCCESS
TEST: '(conj (list 1) 2)' -> ['',(2 1)] -> SUCCESS
TEST: '(conj (list 2 3) 4)' -> ['',(4 2 3)] -> SUCCESS
TEST: '(conj (list 2 3) 4 5 6)' -> ['',(6 5 4 2 3)] -> SUCCESS
TEST: '(conj (list 1) (list 2 3))' -> ['',((2 3) 1)] -> SUCCESS
TEST: '(conj [] 1)' -> ['',[1]] -> SUCCESS
TEST: '(conj [1] 2)' -> ['',[1 2]] -> SUCCESS
TEST: '(conj [2 3] 4)' -> ['',[2 3 4]] -> SUCCESS
TEST: '(conj [2 3] 4 5 6)' -> ['',[2 3 4 5 6]] -> SUCCESS
TEST: '(conj [1] [2 3])' -> ['',[1 [2 3]]] -> SUCCESS

Testing seq function
TEST: '(seq "abc")' -> ['',("a" "b" "c")] -> SUCCESS
TEST: '(apply str (seq "this is a test"))' -> ['',"this is a test"] -> SUCCESS
TEST: "(seq '(2 3 4))" -> ['',(2 3 4)] -> SUCCESS
TEST: '(seq [2 3 4])' -> ['',(2 3 4)] -> SUCCESS
TEST: '(seq "")' -> ['',nil] -> SUCCESS
TEST: "(seq '())" -> ['',nil] -> SUCCESS
TEST: '(seq [])' -> ['',nil] -> SUCCESS
TEST: '(seq nil)' -> ['',nil] -> SUCCESS

Testing metadata on collections
TEST: '(meta [1 2 3])' -> ['',nil] -> SUCCESS
TEST: '(with-meta [1 2 3] {"a" 1})' -> ['',[1 2 3]] -> SUCCESS
TEST: '(meta (with-meta [1 2 3] {"a" 1}))' -> ['',{"a" 1}] -> SUCCESS
TEST: '(vector? (with-meta [1 2 3] {"a" 1}))' -> ['',true] -> SUCCESS
TEST: '(meta (with-meta [1 2 3] "abc"))' -> ['',"abc"] -> SUCCESS
TEST: '(with-meta [] "abc")' -> ['',[]] -> SUCCESS
TEST: '(meta (with-meta (list 1 2 3) {"a" 1}))' -> ['',{"a" 1}] -> SUCCESS
TEST: '(list? (with-meta (list 1 2 3) {"a" 1}))' -> ['',true] -> SUCCESS
TEST: '(with-meta (list) {"a" 1})' -> ['',()] -> SUCCESS
TEST: '(empty? (with-meta (list) {"a" 1}))' -> ['',true] -> SUCCESS
TEST: '(meta (with-meta {"abc" 123} {"a" 1}))' -> ['',{"a" 1}] -> SUCCESS
TEST: '(map? (with-meta {"abc" 123} {"a" 1}))' -> ['',true] -> SUCCESS
TEST: '(with-meta {} {"a" 1})' -> ['',{}] -> SUCCESS
TEST: '(def! l-wm (with-meta [4 5 6] {"b" 2}))' -> ['',[4 5 6]] -> SUCCESS
TEST: '(meta l-wm)' -> ['',{"b" 2}] -> SUCCESS
TEST: '(meta (with-meta l-wm {"new_meta" 123}))' -> ['',{"new_meta" 123}] -> SUCCESS
TEST: '(meta l-wm)' -> ['',{"b" 2}] -> SUCCESS

Testing metadata on builtin functions
TEST: '(meta +)' -> ['',nil] -> SUCCESS
TEST: '(def! f-wm3 ^{"def" 2} +)' -> ['',] -> SUCCESS (result ignored)
TEST: '(meta f-wm3)' -> ['',{"def" 2}] -> SOFT FAIL (line 272):
    Expected : '.*\n\\{\\"def\\"\\ 2\\}'
    Got      : "(meta f-wm3)\nERROR: 'f-wm3' not found"
TEST: '(meta +)' -> ['',nil] -> SUCCESS
Loading sumdown from computations.mal
TEST: '(load-file "./computations.mal")' -> ['',nil] -> SUCCESS

Testing time-ms function
TEST: '(def! start-time (time-ms))' -> ['',] -> SUCCESS (result ignored)
TEST: '(= start-time 0)' -> ['',false] -> SUCCESS
TEST: '(sumdown 10) ; Waste some time' -> ['',55] -> SUCCESS
TEST: '(> (time-ms) start-time)' -> ['',true] -> SUCCESS

Test that defining a macro does not mutate an existing function.
TEST: '(def! f (fn* [x] (number? x)))' -> ['',] -> SUCCESS (result ignored)
TEST: '(defmacro! m f)' -> ['',] -> SUCCESS (result ignored)
TEST: '(f (+ 1 1))' -> ['',true] -> SOFT FAIL (line 295):
    Expected : '.*\ntrue'
    Got      : '(f (+ 1 1))\nfalse'
TEST: '(m (+ 1 1))' -> ['',false] -> SUCCESS

FAILURES:
SOFT FAILED TEST (line 272): (meta f-wm3) -> ['',{"def" 2}]:
    Expected : '.*\n\\{\\"def\\"\\ 2\\}'
    Got      : "(meta f-wm3)\nERROR: 'f-wm3' not found"
SOFT FAILED TEST (line 295): (f (+ 1 1)) -> ['',true]:
    Expected : '.*\ntrue'
    Got      : '(f (+ 1 1))\nfalse'

TEST RESULTS (for ./stepA_mal.mal):
    2: soft failing tests
    0: failing tests
  105: passing tests
  107: total tests

